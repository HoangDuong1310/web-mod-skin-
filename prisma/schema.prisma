generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextIndex", "fullTextSearch"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId], map: "accounts_userId_fkey")
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "sessions_userId_fkey")
  @@map("sessions")
}

model User {
  id                String            @id @default(cuid())
  name              String?
  email             String            @unique
  emailVerified     DateTime?
  image             String?
  role              Role              @default(USER)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  deletedAt         DateTime?
  password          String?
  passwordUpdatedAt DateTime?
  accounts          Account[]
  auditLogs         AuditLog[]
  downloads         Download[]
  notifications     notifications[]
  passwordHistory   PasswordHistory[]
  posts             Post[]
  reviews           Review[]
  sessions          Session[]
  donations         Donation[]
  donationGoals     DonationGoal[]
  customSkins       CustomSkin[]
  skinSubmissions   SkinSubmission[]
  reviewedSubmissions SkinSubmission[] @relation("SkinReviewer")
  skinDownloads     SkinDownload[]

  @@index([email])
  @@index([createdAt])
  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Category {
  id              String     @id @default(cuid())
  name            String
  slug            String     @unique
  description     String?    @db.Text
  image           String?
  parentId        String?
  status          Status     @default(PUBLISHED)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  deletedAt       DateTime?
  metaTitle       String?
  metaDescription String?    @db.Text
  parent          Category?  @relation("CategoryParent", fields: [parentId], references: [id])
  children        Category[] @relation("CategoryParent")
  products        Product[]

  @@index([slug])
  @@index([parentId])
  @@index([status])
  @@index([createdAt])
  @@map("categories")
}

model Product {
  id              String     @id @default(cuid())
  title           String
  slug            String     @unique
  description     String?    @db.Text
  content         String?    @db.Text
  status          Status     @default(DRAFT)
  price           Decimal    @db.Decimal(10, 2)
  comparePrice    Decimal?   @db.Decimal(10, 2)
  stock           Int        @default(0)
  images          String?    @db.LongText
  categoryId      String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  deletedAt       DateTime?
  metaTitle       String?
  metaDescription String?    @db.Text
  averageRating   Decimal    @default(0.00) @db.Decimal(3, 2)
  totalReviews    Int        @default(0)
  version         String?
  downloadUrl     String?
  externalUrl     String?
  fileSize        String?
  filename        String?
  downloads       Download[]
  category        Category?  @relation(fields: [categoryId], references: [id])
  reviews         Review[]

  @@index([slug])
  @@index([categoryId])
  @@index([status])
  @@index([price])
  @@index([createdAt])
  @@index([averageRating])
  @@fulltext([title, description])
  @@map("products")
}

model Download {
  id         String   @id @default(cuid())
  userId     String?
  productId  String
  downloadIp String?
  userAgent  String?
  createdAt  DateTime @default(now())
  product    Product  @relation(fields: [productId], references: [id])
  user       User?    @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([productId, createdAt])
  @@index([createdAt])
  @@map("downloads")
}

model Post {
  id              String    @id @default(cuid())
  title           String
  slug            String    @unique
  excerpt         String?   @db.Text
  content         String    @db.Text
  status          Status    @default(DRAFT)
  featured        Boolean   @default(false)
  authorId        String
  publishedAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?
  metaTitle       String?
  metaDescription String?   @db.Text
  featuredImage   String?
  postTags        PostTag[]
  author          User      @relation(fields: [authorId], references: [id])

  @@index([slug])
  @@index([authorId])
  @@index([status])
  @@index([publishedAt])
  @@index([createdAt])
  @@fulltext([title, excerpt, content])
  @@map("posts")
}

model Tag {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  description String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  postTags    PostTag[]

  @@index([slug])
  @@map("tags")
}

model PostTag {
  id     String @id @default(cuid())
  postId String
  tagId  String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@index([tagId], map: "post_tags_tagId_fkey")
  @@map("post_tags")
}

model Review {
  id         String    @id @default(cuid())
  productId  String
  rating     Int
  title      String
  content    String    @db.Text
  userId     String?
  guestName  String?
  guestEmail String?
  isVerified Boolean   @default(false)
  isVisible  Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?
  product    Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  user       User?     @relation(fields: [userId], references: [id])

  @@index([productId, createdAt])
  @@index([userId])
  @@index([rating])
  @@index([isVisible, isVerified])
  @@map("reviews")
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String?  @db.Text
  category  String
  isPublic  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([key, category])
  @@map("settings")
}

model PasswordHistory {
  id           String   @id @default(cuid())
  userId       String
  passwordHash String
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("password_history")
}

model AccountLockout {
  id          String   @id @default(cuid())
  identifier  String   @unique
  lockedUntil DateTime
  reason      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([identifier])
  @@index([lockedUntil])
  @@map("account_lockouts")
}

model FailedLoginAttempts {
  id          String   @id @default(cuid())
  identifier  String   @unique
  attempts    Int      @default(1)
  lastAttempt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([identifier])
  @@index([lastAttempt])
  @@map("failed_login_attempts")
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String
  action    String
  details   String?  @db.Text
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model notifications {
  id             String                       @id
  title          String
  message        String                       @db.Text
  type           notifications_type           @default(INFO)
  isActive       Boolean                      @default(true)
  startDate      DateTime?
  endDate        DateTime?
  targetAudience notifications_targetAudience @default(ALL)
  position       notifications_position       @default(TOP)
  priority       Int                          @default(0)
  dismissible    Boolean                      @default(true)
  linkUrl        String?
  linkText       String?
  createdById    String
  createdAt      DateTime                     @default(now())
  updatedAt      DateTime
  deletedAt      DateTime?
  users          User                         @relation(fields: [createdById], references: [id])

  @@index([createdAt])
  @@index([createdById])
  @@index([isActive, startDate, endDate])
  @@index([priority])
  @@index([type])
}

enum Role {
  ADMIN
  STAFF
  USER
}

enum Status {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum notifications_type {
  INFO
  WARNING
  ERROR
  SUCCESS
}

enum notifications_targetAudience {
  ALL
  AUTHENTICATED
  GUEST
}

// Donation models for fundraising system
model Donation {
  id           String   @id @default(cuid())
  amount       Decimal  @db.Decimal(10, 2)
  currency     String   @default("USD")
  
  // Donor information (optional for anonymous donations)
  userId       String?
  donorName    String?   // For anonymous or guest donations
  donorEmail   String?   // For anonymous donations (optional)
  isAnonymous  Boolean   @default(false)
  
  // Payment information
  paymentMethod PaymentMethod @default(MANUAL)
  transactionId String?  @unique // External transaction ID
  kofiTransactionId String? // Ko-fi specific transaction ID
  
  // VietQR information (for bank transfers)
  bankCode     String?   // Bank identifier for VietQR
  qrCodeUrl    String?   // Generated VietQR URL
  transferNote String?   // Bank transfer note/reference
  
  // Status
  status       DonationStatus @default(PENDING)
  
  // Message (optional)
  message      String?   @db.Text
  isMessagePublic Boolean @default(true)
  
  // Metadata
  ipAddress    String?
  userAgent    String?
  
  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  completedAt  DateTime?
  
  // Relations
  user         User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  goal         DonationGoal? @relation(fields: [goalId], references: [id], onDelete: SetNull)
  goalId       String?
  
  @@index([userId])
  @@index([goalId])
  @@index([status])
  @@index([paymentMethod])
  @@index([createdAt])
  @@index([isAnonymous])
  @@index([kofiTransactionId])
  @@map("donations")
}

model DonationGoal {
  id           String   @id @default(cuid())
  title        String
  description  String?  @db.Text
  targetAmount Decimal  @db.Decimal(10, 2)
  currentAmount Decimal @default(0) @db.Decimal(10, 2)
  currency     String   @default("USD")
  
  // Goal settings
  isActive     Boolean  @default(true)
  isVisible    Boolean  @default(true)
  priority     Int      @default(0) // Higher priority goals show first
  
  // Timeframe
  startDate    DateTime @default(now())
  endDate      DateTime?
  
  // Display settings
  showProgress Boolean  @default(true)
  showAmount   Boolean  @default(true)
  showDonors   Boolean  @default(true)
  
  // Metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  createdBy    String
  
  // Relations
  creator      User     @relation(fields: [createdBy], references: [id])
  donations    Donation[]
  
  @@index([isActive, isVisible])
  @@index([priority])
  @@index([startDate, endDate])
  @@map("donation_goals")
}

enum DonationStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  KOFI
  BANK_TRANSFER
  MANUAL
}

enum notifications_position {
  TOP
  BOTTOM
}

// Custom Skins Models for League of Legends
model Champion {
  id              Int             @id
  name            String
  description     String?
  alias           String
  contentId       String
  squarePortraitPath String
  roles           String?         @db.Text // JSON array of roles
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  customSkins     CustomSkin[]
  skinSubmissions SkinSubmission[]

  @@index([alias])
  @@index([name])
  @@map("champions")
}

model SkinCategory {
  id          String     @id @default(cuid())
  name        String     @unique
  slug        String     @unique
  description String?    @db.Text
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  customSkins CustomSkin[]
  skinSubmissions SkinSubmission[]

  @@index([slug])
  @@map("skin_categories")
}

model CustomSkin {
  id              String           @id @default(cuid())
  name            String
  description     String           @db.Text
  version         String
  championId      Int
  categoryId      String
  authorId        String
  
  // File information
  fileName        String
  filePath        String           // Path to uploaded file
  fileSize        String           // Human readable file size
  fileType        SkinFileType     // zip, rar, fantome
  
  // Preview images
  previewImages   String?          @db.LongText // JSON array of image paths
  thumbnailImage  String?          // Main preview image
  
  // Status and metadata
  status          SkinStatus       @default(APPROVED)
  downloadCount   Int              @default(0)
  
  // Timestamps
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  
  // Relations
  champion        Champion         @relation(fields: [championId], references: [id])
  category        SkinCategory     @relation(fields: [categoryId], references: [id])
  author          User             @relation(fields: [authorId], references: [id])
  downloads       SkinDownload[]
  
  @@index([championId])
  @@index([categoryId])
  @@index([authorId])
  @@index([status])
  @@index([createdAt])
  @@fulltext([name, description])
  @@map("custom_skins")
}

model SkinSubmission {
  id              String           @id @default(cuid())
  name            String
  description     String           @db.Text
  version         String
  championId      Int
  categoryId      String
  submitterId     String
  
  // File information
  fileName        String
  filePath        String           // Path to uploaded file
  fileSize        String
  fileType        SkinFileType
  
  // Preview images
  previewImages   String?          @db.LongText // JSON array of image paths
  thumbnailImage  String?
  
  // Review information
  status          SubmissionStatus @default(PENDING)
  reviewedById    String?
  reviewedAt      DateTime?
  adminNotes      String?          @db.Text     // Internal admin notes
  feedbackMessage String?          @db.Text     // Feedback for submitter
  
  // Timestamps
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  
  // Relations
  champion        Champion         @relation(fields: [championId], references: [id])
  category        SkinCategory     @relation(fields: [categoryId], references: [id])
  submitter       User             @relation(fields: [submitterId], references: [id])
  reviewer        User?            @relation("SkinReviewer", fields: [reviewedById], references: [id])
  
  @@index([championId])
  @@index([categoryId])
  @@index([submitterId])
  @@index([reviewedById])
  @@index([status])
  @@index([createdAt])
  @@map("skin_submissions")
}

model SkinDownload {
  id         String     @id @default(cuid())
  userId     String?
  skinId     String
  downloadIp String?
  userAgent  String?
  createdAt  DateTime   @default(now())
  
  skin       CustomSkin @relation(fields: [skinId], references: [id])
  user       User?      @relation(fields: [userId], references: [id])
  
  @@index([userId, createdAt])
  @@index([skinId, createdAt])
  @@index([createdAt])
  @@map("skin_downloads")
}

enum SkinFileType {
  ZIP
  RAR
  FANTOME
}

enum SkinStatus {
  APPROVED
  FEATURED
  HIDDEN
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  NEEDS_REVISION
}

// Banner model for announcements, livestream notifications, etc.
model Banner {
  id              String       @id @default(cuid())
  title           String       // Banner title
  content         String?      @db.Text // Banner content/description
  linkUrl         String?      // Link to navigate when clicked
  linkText        String?      // Text for the link button
  imageUrl        String?      // Banner image URL
  backgroundColor String?      // Custom background color (hex)
  textColor       String?      // Custom text color (hex)
  
  // Display settings
  type            BannerType   @default(INFO)
  position        BannerPosition @default(TOP)
  isActive        Boolean      @default(true)
  isDismissible   Boolean      @default(true)
  showOnMobile    Boolean      @default(true)
  
  // Scheduling
  startDate       DateTime?    // When to start showing
  endDate         DateTime?    // When to stop showing
  
  // Priority (higher = more important)
  priority        Int          @default(0)
  
  // Target audience
  targetAudience  BannerAudience @default(ALL)
  
  // For mobile app integration
  appVisible      Boolean      @default(true) // Show in mobile app
  appData         String?      @db.Text // JSON data for app customization
  
  // Statistics
  viewCount       Int          @default(0)
  clickCount      Int          @default(0)
  
  // Metadata
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?
  
  @@index([isActive, startDate, endDate])
  @@index([priority])
  @@index([type])
  @@index([position])
  @@index([appVisible])
  @@map("banners")
}

enum BannerType {
  INFO        // General information
  LIVESTREAM  // Livestream announcement
  PROMOTION   // Promotional banner
  WARNING     // Warning/Alert
  SUCCESS     // Success message
  EVENT       // Special event
}

enum BannerPosition {
  TOP         // Fixed at top
  BOTTOM      // Fixed at bottom
  MODAL       // Show as modal/popup
}

enum BannerAudience {
  ALL         // Everyone
  AUTHENTICATED // Logged in users only
  GUEST       // Guest users only
}
