// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextIndex", "fullTextSearch"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Auth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String       @unique
  emailVerified DateTime?
  image         String?
  password      String?      // For credential-based authentication
  passwordUpdatedAt DateTime? // Track when password was last updated
  role          Role         @default(USER)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  deletedAt     DateTime?
  
  // Relations
  accounts         Account[]
  sessions         Session[]
  downloads        Download[]
  posts            Post[]
  reviews          Review[]
  passwordHistory  PasswordHistory[]
  auditLogs        AuditLog[]

  @@index([email])
  @@index([createdAt])
  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Category model with hierarchical structure
model Category {
  id          String      @id @default(cuid())
  name        String
  slug        String      @unique
  description String?     @db.Text
  image       String?
  parentId    String?
  status      Status      @default(PUBLISHED)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?

  // SEO fields
  metaTitle       String?
  metaDescription String? @db.Text

  // Relations
  parent     Category?  @relation("CategoryParent", fields: [parentId], references: [id])
  children   Category[] @relation("CategoryParent")
  products   Product[]

  @@index([slug])
  @@index([parentId])
  @@index([status])
  @@index([createdAt])
  @@map("categories")
}

// Product model
model Product {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  description String?   @db.Text
  content     String?   @db.Text
  version     String?   // Product version
  status      Status    @default(DRAFT)
  price       Decimal   @db.Decimal(10, 2)
  comparePrice Decimal? @db.Decimal(10, 2)
  stock       Int       @default(0)
  images      Json?     // Array of image URLs
  categoryId  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // Download fields
  downloadUrl String?   // Direct download URL for local files
  filename    String?   // Original filename
  fileSize    String?   // File size (formatted string like "2.5MB")
  externalUrl String?   // External download link (app store, etc.)

  // Rating aggregation fields
  averageRating Decimal @default(0) @db.Decimal(3, 2)
  totalReviews  Int     @default(0)

  // SEO fields
  metaTitle       String?
  metaDescription String? @db.Text

  // Relations
  category    Category?   @relation(fields: [categoryId], references: [id])
  downloads   Download[]
  reviews     Review[]

  @@index([slug])
  @@index([categoryId])
  @@index([status])
  @@index([price])
  @@index([createdAt])
  @@index([averageRating])
  @@fulltext([title, description])
  @@map("products")
}

// Download model - simplified tracking for software downloads
model Download {
  id         String    @id @default(cuid())
  userId     String?   // Allow null for anonymous downloads
  productId  String
  downloadIp String?   // Track IP for analytics
  userAgent  String?   // Track user agent for analytics
  createdAt  DateTime  @default(now())
  
  // Relations
  user    User?   @relation(fields: [userId], references: [id])
  product Product @relation(fields: [productId], references: [id])
  
  @@index([userId, createdAt])
  @@index([productId, createdAt])
  @@index([createdAt])
  @@map("downloads")
}

// Post model for blog/content
model Post {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  excerpt     String?   @db.Text
  content     String    @db.Text
  status      Status    @default(DRAFT)
  featured    Boolean   @default(false)
  authorId    String
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // SEO fields
  metaTitle       String?
  metaDescription String? @db.Text
  featuredImage   String?

  // Relations
  author   User      @relation(fields: [authorId], references: [id])
  postTags PostTag[]

  @@index([slug])
  @@index([authorId])
  @@index([status])
  @@index([publishedAt])
  @@index([createdAt])
  @@fulltext([title, excerpt, content])
  @@map("posts")
}

// Tag model
model Tag {
  id          String    @id @default(cuid())
  name        String    @unique
  slug        String    @unique
  description String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  // Relations
  postTags PostTag[]

  @@index([slug])
  @@map("tags")
}

// PostTag junction table
model PostTag {
  id     String @id @default(cuid())
  postId String
  tagId  String

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@map("post_tags")
}

// Review model for product ratings and reviews
model Review {
  id        String   @id @default(cuid())
  productId String
  rating    Int      // 1-5 stars
  title     String
  content   String   @db.Text
  
  // For authenticated users
  userId    String?
  
  // For guest reviews
  guestName  String?
  guestEmail String?
  
  // Moderation
  isVerified Boolean  @default(false)
  isVisible  Boolean  @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([productId, createdAt])
  @@index([userId])
  @@index([rating])
  @@index([isVisible, isVerified])
  @@map("reviews")
}

// Settings model for system configuration
model Setting {
  id        String   @id @default(cuid())
  key       String   @unique // e.g. 'site.name', 'email.smtp.host'
  value     String?  @db.Text // JSON string for complex values
  category  String   // 'site', 'email', 'security', 'system', 'notifications'
  isPublic  Boolean  @default(false) // Whether setting can be accessed publicly
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([key, category])
  @@map("settings")
}

// Security-related models
model PasswordHistory {
  id           String   @id @default(cuid())
  userId       String
  passwordHash String
  createdAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("password_history")
}

model AccountLockout {
  id         String   @id @default(cuid())
  identifier String   @unique // email or username
  lockedUntil DateTime
  reason     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@index([lockedUntil])
  @@map("account_lockouts")
}

model FailedLoginAttempts {
  id          String   @id @default(cuid())
  identifier  String   @unique // email or username
  attempts    Int      @default(1)
  lastAttempt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([identifier])
  @@index([lastAttempt])
  @@map("failed_login_attempts")
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String
  action    String
  details   String?  @db.Text
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// Enums
enum Role {
  ADMIN
  STAFF
  USER
}

enum Status {
  DRAFT
  PUBLISHED
  ARCHIVED
}

